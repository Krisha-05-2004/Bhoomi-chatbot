<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>🌱 Bhoomi – Smart Farming Companion</title>
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      background-image: url("https://images.unsplash.com/photo-1500937386664-56d1dfef3854?auto=format&fit=crop&w=1950&q=80");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .overlay {
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      background-color: rgba(255, 255, 255, 0.5);
      padding: 20px;
      border-radius: 16px;
      width: 500px;
      height: 700px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 25px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 1;
    }
    header{background:#3c9d47;color:#fff;padding:16px 20px;font-size:20px;font-weight:600}
    #chatbox{flex:1;padding:18px;overflow:auto;background:linear-gradient(#f7fff7,#ffffff)}
    .bot,.user{margin:12px 0;padding:14px;border-radius:12px;max-width:92%;line-height:1.45}
    .bot{background:#e6f5e6;align-self:flex-start;font-size:15px}
    .user{background:#dbeeff;align-self:flex-end}
    .controls{display:flex;gap:8px;padding:12px;border-top:1px solid #eee;background:#fafafa;align-items:center}
    select,input[type=text]{padding:10px;border-radius:8px;border:1px solid #ccc}
    #question{flex:1;min-width:140px}
    .btn{background:#3c9d47;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer}
    .icon-btn{background:transparent;border:1px solid #ddd;padding:8px;border-radius:8px;cursor:pointer}
    .msg-controls{display:flex;gap:8px;margin-top:6px;font-size:12px}
    .control-btn{background:transparent;border:none;cursor:pointer;padding:6px;border-radius:6px}
  </style>
</head>
<body>
  <div class="overlay">
    <header>🌱 Bhoomi – Smart Farming Companion</header>
    <div id="chatbox">
      <div class="bot">Hello! I’m <strong>Bhoomi</strong> 🌾<br/>Ask me anything about farming — water, soil, crops, or simple tips.</div>
    </div>
    <div class="controls">
      <select id="lang-select">
        <option value="en-IN">English</option>
        <option value="hi-IN">हिन्दी</option>
        <option value="kn-IN">ಕನ್ನಡ</option>
        <option value="te-IN">తెలుగు</option>
      </select>
      <!-- File upload removed due to OpenAI upload migration issues -->
      <button id="record-btn" class="icon-btn" title="Record audio">🎙️</button>
      <input id="question" type="text" placeholder="Type your question here..." />
      <button id="send-btn" class="btn">Send</button>
    </div>
  </div>

  <script>
    // small helpers
    function createEl(tag, cls, html){const e=document.createElement(tag);if(cls) e.className=cls;if(html!=null) e.innerHTML=html;return e}

    // create a message element with a separate content node and controls
    function addMessage(sender, text){
      const c=document.getElementById('chatbox');
      const el=createEl('div',sender);
      const content = createEl('div','msg-content',(text||'').replace(/\n/g,'<br/>'));
      el.appendChild(content);

      // controls: copy, speak (bot), edit (user)
      const controls = createEl('div','msg-controls');
      const copyBtn = createEl('button','control-btn','📋'); copyBtn.title='Copy'; copyBtn.addEventListener('click',()=>copyText(text||''));
      controls.appendChild(copyBtn);
      if(sender==='bot'){
        const speakBtn = createEl('button','control-btn','🔊'); speakBtn.title='Speak'; speakBtn.addEventListener('click',()=>speakText(text||'')); controls.appendChild(speakBtn);
      }
      if(sender==='user'){
        const editBtn=createEl('button','control-btn','✏️'); editBtn.title='Edit'; editBtn.addEventListener('click',()=>beginInlineEdit(el)); controls.appendChild(editBtn);
      }
      el.appendChild(controls);

      c.appendChild(el);
      c.scrollTop=c.scrollHeight;
      return el;
    }

    // create a bot placeholder; if afterEl provided, insert after that element
    function addBotPlaceholder(afterEl){
      const c=document.getElementById('chatbox');
      const el=createEl('div','bot','<em>Bhoomi is thinking...</em>');
      if(afterEl && afterEl.parentElement === c){
        c.insertBefore(el, afterEl.nextElementSibling);
      } else {
        c.appendChild(el);
      }
      c.scrollTop=c.scrollHeight;
      return el;
    }

    function copyText(t){ if(navigator.clipboard) navigator.clipboard.writeText(t).then(()=>showToast('Copied')) }

    function showToast(msg){ const t=createEl('div','toast',msg); document.body.appendChild(t); t.style.position='fixed'; t.style.left='50%'; t.style.bottom='24px'; t.style.transform='translateX(-50%)'; t.style.background='rgba(0,0,0,0.8)'; t.style.color='#fff'; t.style.padding='8px 12px'; t.style.borderRadius='8px'; setTimeout(()=>t.remove(),1400) }

  // Simple TTS: speak the provided text (cancels any existing speech) and pick a matching voice when available
  function speakText(text){
    try{
      if(!text) return;
      if(window.speechSynthesis && typeof SpeechSynthesisUtterance !== 'undefined'){
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(cleanForTTS(text));
        const lang = document.getElementById('lang-select')?.value;
        if(lang) u.lang = lang;

        // try to pick a matching voice for the selected language
        try{
          const voices = window.speechSynthesis.getVoices() || [];
          if(voices.length){
            const prefix = (lang||'').split('-')[0];
            let match = voices.find(v=>v.lang && v.lang.toLowerCase().startsWith(prefix));
            if(!match){ match = voices.find(v=>v.name && v.name.toLowerCase().includes(prefix)); }
            if(match) u.voice = match;
          } else {
            // some browsers populate voices asynchronously
            window.speechSynthesis.onvoiceschanged = ()=>{
              const vs = window.speechSynthesis.getVoices() || [];
              const prefix = (lang||'').split('-')[0];
              let m = vs.find(v=>v.lang && v.lang.toLowerCase().startsWith(prefix));
              if(!m) m = vs.find(v=>v.name && v.name.toLowerCase().includes(prefix));
              if(m) u.voice = m;
              window.speechSynthesis.speak(u);
            };
          }
        }catch(e){ /* ignore voice selection errors */ }

        // speak (if onvoiceschanged handled it will speak too)
        window.speechSynthesis.speak(u);
      } else { showToast('TTS not supported'); }
    }catch(e){ console.error(e); showToast('TTS error') }
  }

  function cleanForTTS(s){ if(!s) return ''; let t=String(s); t=t.replace(/`+/g,''); t=t.replace(/\*+/g,''); t=t.replace(/•/g,','); t=t.replace(/\n+/g,'. '); t=t.replace(/\s+/g,' '); return t.trim(); }

  // Map detected short language codes (whisper/langdetect) to our select values
  function mapDetectedLangToSelectCode(detected){
    if(!detected) return null;
    const code = String(detected).toLowerCase();
    if(code.startsWith('hi')) return 'hi-IN';
    if(code.startsWith('kn')) return 'kn-IN';
    if(code.startsWith('te')) return 'te-IN';
    if(code.startsWith('en')) return 'en-IN';
    // fallback: if exact match of our options
    const opts = ['en-IN','hi-IN','kn-IN','te-IN'];
    for(const o of opts) if(o.toLowerCase().startsWith(code)) return o;
    return null;
  }

    // currentEdit tracks an inline edit in progress: { userEl, botEl }
    let currentEdit = null;

    async function sendMessage(){
      const q=document.getElementById('question');
      const txt=(q.value||'').trim();
      if(!txt) return;
      q.value='';

      // If we're editing an existing user message, update that message and reuse its bot reply element
      if(currentEdit && currentEdit.userEl){
  // update user message content (preserve controls)
  const userEl = currentEdit.userEl;
  const contentDiv = userEl.querySelector('.msg-content');
  if(contentDiv){ contentDiv.innerHTML = txt.replace(/\n/g,'<br/>'); } else { try{ if(userEl.firstChild) userEl.firstChild.textContent = txt; else userEl.textContent = txt }catch(e){} }

        // show thinking in existing bot element or create one if missing
        let botEl = currentEdit.botEl;
        if(botEl && botEl.parentElement){
          botEl.querySelector('.msg-content')?.remove?.();
          // replace content safely
          botEl.innerHTML = '<em>Bhoomi is thinking...</em>';
        } else {
          // create placeholder directly after userEl so response updates in-place
          botEl = addBotPlaceholder(currentEdit.userEl);
          currentEdit.botEl = botEl;
        }

        // perform request and update botEl in-place
        try{
          const lang=document.getElementById('lang-select').value;
          const res=await fetch('/ask',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({question:txt,lang})});
          const j=await res.json();
          botEl.innerHTML = (j.answer||j.result||'No answer').replace(/\n/g,'<br/>');
        }catch(e){ botEl.innerHTML='⚠️ Error: Unable to reach server.' }

        // clear edit state and restore send button label
        currentEdit = null;
        const cancelBtn = document.getElementById('cancel-edit-btn'); if(cancelBtn) cancelBtn.style.display='none';
        document.getElementById('send-btn').textContent = 'Send';
        return;
      }

      // Normal send (not editing): append user and bot placeholder
      addMessage('user',txt);
      const ph=addBotPlaceholder();
      try{
        const lang=document.getElementById('lang-select').value;
        const res=await fetch('/ask',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({question:txt,lang})});
        const j=await res.json();
        ph.innerHTML=(j.answer||j.result||'No answer').replace(/\n/g,'<br/>');
      }catch(e){ph.innerHTML='⚠️ Error: Unable to reach server.'}
    }

    document.getElementById('send-btn').addEventListener('click',sendMessage);
    document.getElementById('question').addEventListener('keypress',e=>{if(e.key==='Enter') sendMessage()});

    // Recording & transcribe
    (function(){
      const rb=document.getElementById('record-btn');
      if(!rb || !navigator.mediaDevices){ if(rb) rb.style.display='none'; return }
      let mr=null, chunks=[];
      rb.addEventListener('click', async ()=>{
        if(!mr || mr.state==='inactive'){
          try{
            const stream=await navigator.mediaDevices.getUserMedia({audio:true});
            mr=new MediaRecorder(stream); chunks=[];
            mr.ondataavailable = e => chunks.push(e.data);
            mr.onstop = async ()=>{
              const blob = new Blob(chunks, {type:'audio/webm'});
              const fd = new FormData(); fd.append('audio', blob, 'rec.webm');
              const ph = addBotPlaceholder();
              try{
                const res = await fetch('/transcribe', { method:'POST', body: fd });
                const d = await res.json();
                ph.innerHTML = 'Transcription: ' + (d.transcript || '');

                // Map detected language (from server) to our lang-select values and set it for downstream sends
                try{
                  const mapped = mapDetectedLangToSelectCode(d.lang);
                  if(mapped){ const s = document.getElementById('lang-select'); if(s) s.value = mapped; }
                }catch(e){}

                if(d.transcript){ document.getElementById('question').value = d.transcript; sendMessage(); }
              }catch(err){ ph.innerHTML = '⚠️ Transcription failed' }
            };
            mr.start(); rb.textContent='⏺️'
          }catch(err){ alert('Cannot access microphone') }
        } else if(mr.state==='recording'){ mr.stop(); rb.textContent='🎙️' }
      })
    })();

    // File upload UI and client handler removed.

    // Inline edit: replace message content with a textarea and show Save/Cancel inside the message controls
    function beginInlineEdit(msgEl){
      try{
        const contentDiv = msgEl.querySelector('.msg-content');
        const orig = contentDiv ? contentDiv.innerText.replace(/\n/g,'') : (msgEl.innerText||'');
        // store original for cancel
        msgEl.dataset.original = orig;

        // replace content with textarea
        const ta = createEl('textarea','inline-edit');
        ta.style.width = '100%'; ta.style.minHeight = '64px'; ta.value = orig;
        if(contentDiv){ contentDiv.innerHTML = ''; contentDiv.appendChild(ta); }
        else { msgEl.insertBefore(ta, msgEl.firstChild); }

        // find adjacent bot element if available
        let botEl = null;
        if(msgEl.nextElementSibling && msgEl.nextElementSibling.classList && msgEl.nextElementSibling.classList.contains('bot')){
          botEl = msgEl.nextElementSibling;
        }
        currentEdit = { userEl: msgEl, botEl };

        // update controls: replace existing controls with Save/Cancel
        const controls = msgEl.querySelector('.msg-controls');
        controls.innerHTML = '';
        const saveBtn = createEl('button','control-btn','💾'); saveBtn.title='Save';
        const cancelBtn = createEl('button','control-btn','✖️'); cancelBtn.title='Cancel';
        controls.appendChild(saveBtn); controls.appendChild(cancelBtn);

        saveBtn.addEventListener('click', async ()=>{
          const newText = ta.value.trim();
          // replace content with updated text immediately
          if(contentDiv){ contentDiv.innerHTML = (newText||'').replace(/\n/g,'<br/>'); }
          // restore original controls (copy + edit)
          restoreMessageControls(msgEl, newText);

          // show thinking placeholder after the edited user message
          let replyEl = currentEdit.botEl;
          if(!replyEl || replyEl.parentElement!==document.getElementById('chatbox')){
            replyEl = addBotPlaceholder(msgEl);
            currentEdit.botEl = replyEl;
          } else {
            replyEl.innerHTML = '<em>Bhoomi is thinking...</em>';
          }

          // send updated question and update replyEl in-place
          try{
            const lang=document.getElementById('lang-select').value;
            const res=await fetch('/ask',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({question:newText,lang})});
            const j=await res.json();
            replyEl.innerHTML = (j.answer||j.result||'No answer').replace(/\n/g,'<br/>');
          }catch(e){ replyEl.innerHTML='⚠️ Error: Unable to reach server.' }

          currentEdit = null;
        });

        cancelBtn.addEventListener('click', ()=>{
          // restore original content and controls
          const origText = msgEl.dataset.original || '';
          if(contentDiv) contentDiv.innerHTML = origText.replace(/\n/g,'<br/>');
          restoreMessageControls(msgEl, origText);
          currentEdit = null;
        });

        // focus textarea for immediate edit
        ta.focus();
      }catch(e){ console.error(e) }
    }

    function restoreMessageControls(msgEl, text){
      const controls = msgEl.querySelector('.msg-controls');
      controls.innerHTML = '';
      const copyBtn = createEl('button','control-btn','📋'); copyBtn.title='Copy'; copyBtn.addEventListener('click',()=>copyText(text||'')); controls.appendChild(copyBtn);
      const editBtn = createEl('button','control-btn','✏️'); editBtn.title='Edit'; editBtn.addEventListener('click',()=>beginInlineEdit(msgEl)); controls.appendChild(editBtn);
    }
  </script>
</body>
</html>
